<!-- Navigation -->
<%#= render 'nav'%>

<nav id="mainNav" class="navbar navbar-default navbar-fixed-top d_nav hide">
  <div class="mrf-gradient"></div>
  <div class="mrf-logo"><a href="/"><img src="assets/logo.png" alt="Moober"/></a></div>
  <div class="new-mrf-logo"><a href="/"><img class="mobile-logo" src="assets/logo2.png" alt="Moober"/></a></div>
  <div class="mrf-menuContainer">
    <ul>
      <li>
        <span class="side-menu-moves-count"><mark>0</mark></span>
        <button class="dsktop-toggle c-hamburger c-hamburger--htx"><span>toggle menu</span></button>
      </li>
      <li class="mrf-contactAction"><a href="/contact"><b>Contact Us</b></a></li>
      <li class="mrf-contactAction startmove"><a href="/start-a-move">Start a Move</a></li>
    </ul>
  </div>
</nav>

<nav id="mblNav" class="navbar navbar-fixed-top mbl_nav hide">
  <div class="mrf-gradient"></div>
  <div class="mbl-mrf-logo"><a href="/"><img class="header__logo" src="assets/logo2.png" alt="Moober"/></a></div>
  <div class="mbl-menuContainer mbl-side-menu">
    <ul>
      <li>
        <span class="side-menu-moves-count"><mark>0</mark></span>
        <button class="mbl-toggle c-hamburger c-hamburger--htx"><span>toggle menu</span></button>
      </li>
    </ul>
  </div>
</nav>

<%= render "shared/mobile_nav" %>

<!-- Header section home video -->
<%= render 'home'%>

<!-- welcome to moovber section -->
<%= render 'welcome_section'%>

<!-- How it Works  -->
<%= render 'home_how_it_works'%>

<!-- realtime notifications -->
<%= render 'realtime' %>

<!-- savings -->
<%= render'savings'%>

<!-- notified -->
<%= render 'notified'%>

<!-- apply section -->
<%= render 'home_apply'%>

<!-- share on facebook -->
<%= render 'share_on_facebook' %>

<!-- download moober -->
<%= render 'download_moober' %>

<!-- Featured on  -->
<%= render 'featured'%>

<!-- footer -->
<%= render 'footer' %>

<%= render 'download_app' %>

<%= render 'shared/scrollify' %>
<div class="mbl-webLateralMenuOverlay"></div>
<div class="mbl-webLateralMenu home-mbl-webLateralMenu">
  <ul>
    <li class="user_moves <%= active_class('/moves') %>"><span class="moves-count"><mark>0</mark></span><a href="/moves">Moves</a></li>
    <li class="<%= active_class('/account-settings') %> account_settings"><a href="/account-settings">Account Setting</a></li>
    <li class="<%= active_class('/payment-methods') %> payment_methods"><a href="/payment-methods">Payment Methods</a></li>
    <li><span class="user-login-logut"></span></li>
  </ul>
</div>
<script>
  document.getElementById('shareBtn').onclick = function() {
    FB.ui({
      method: 'share',
      display: 'popup',
      scope: 'email,user_birthday',
      href: 'http://50.116.5.156/',
    }, function(response){ 
        if (response != undefined) {
          "<%= session[:sharebutton] = true %>"
          localStorage.setItem('homapage_share', "true");
          window.location.href = "http://stage.moober.com/auth/facebook";
          // window.location.href = "http://50.116.5.156/auth/facebook";
          // window.location.href = "http://localhost:3000/auth/facebook";
        // };
        }
    });
  }
  $(document).ready(function(){
    $(".mrf-gradient").click();
    var homepageShare = localStorage.getItem('homapage_share');
    <% if session[:fb_token].present? && session[:email].present? && session[:password] %>
      var API_URL = "http://45.56.72.52/api/userapi/";
      var email = "<%= session[:email] %>"
      var uid = "<%= session[:uid] %>"
      var name = "<%= session[:name] %>"
      var image = "<%= session[:image] %>"
      var token = "<%= session[:token] %>"
      fb_signin_params = '{"fullname":"'+name+'","profile_pic":"'+image+'","email":"'+email+'","device_id":"","token":"'+token+'","social_id":"'+uid+'"}'
        if (email != '' && homepageShare == "true") { 
          $.ajax({
            url: API_URL+'socialLogin',
            method: 'POST',
            data: fb_signin_params,
            success: function (data) {
              console.log(data);
              localStorage.setItem('full_name', data.data.fullname)
              localStorage.setItem('phone_number', data.data.phone)
              localStorage.setItem('user_id', data.data.user_id)
              localStorage.setItem('email', data.data.email);
              var current_user = localStorage.getItem('user_id');
              var startmov_login = localStorage.getItem('statmov_signin');
              if (current_user != "" && current_user != null && current_user != undefined) {
                $('.user-login-logut').html("<a href='javascript:;' class='user-logout'>Sign Out</a>")
                $('.user-signup').html("");
                $('.fb-promocode').show();
                $('#shareBtn').hide();
                $('.user_moves').show();
                $('.account_settings').show();
                $('.payment_methods').show();
                userMovesRequest(current_user)
              }else {
                $('.user_moves').hide();
                $('.user-login-logut').html("<a href='/signin'>Sign In</a>")
                $('.user-signup').html("<a href='/signup'>Sign Up</a>")
                $('.account_settings').hide();
                $('.payment_methods').hide();
              }
            },
            error: function (o) {
              console.log(o)
            }
          });
        }
        <%= session[:email] = nil %>
        <%= session[:password] = nil %>
        <%= session[:uid] = nil %>
        <%= session[:name] = nil %>
        <%= session[:image] = nil %>
        <%= session[:token] = nil %>
        localStorage.setItem('homapage_share', "")
    <% end %>
  });
</script>


<div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" style="margin-top:100px;">
  <div class="modal-dialog" role="document">
    <div class="modal-content">
      <div class="modal-body video-modal-body">
        <button type="button" class="close close-popup" data-dismiss="modal"><span class="badge">x</span></button>
        <video loop controls id="video1" style="width: 100%; height: auto; margin:0 auto; frameborder:0;" poster="/assets/Welcome to Moober.png">
          <source src="https://s3-us-west-2.amazonaws.com/moober/Moober_Promo_Video.mp4" type="video/mp4">
        </video>
      </div>
    </div>
  </div>
</div>




<script type="text/javascript">
  $(document).ready(function(){
    $('#myModal').on('shown.bs.modal', function () {
      $('#video1')[0].play();
    })
    $('#myModal').on('hidden.bs.modal', function () {
      $('#video1')[0].pause();
    })
  });
</script>

<script type="text/javascript">
  /*! npm.im/iphone-inline-video 2.2.2 */
var enableInlineVideo = (function () {
'use strict';

/*! npm.im/intervalometer */
function intervalometer(cb, request, cancel, requestParameter) {
  var requestId;
  var previousLoopTime;
  function loop(now) {
    // must be requested before cb() because that might call .stop()
    requestId = request(loop, requestParameter);

    // called with "ms since last call". 0 on start()
    cb(now - (previousLoopTime || now));

    previousLoopTime = now;
  }
  return {
    start: function start() {
      if (!requestId) { // prevent double starts
        loop(0);
      }
    },
    stop: function stop() {
      cancel(requestId);
      requestId = null;
      previousLoopTime = 0;
    }
  };
}

function frameIntervalometer(cb) {
  return intervalometer(cb, requestAnimationFrame, cancelAnimationFrame);
}

function preventEvent(element, eventName, test) {
  function handler(e) {
    if (!test || test(element, eventName)) {
      e.stopImmediatePropagation();
      // // console.log(eventName, 'prevented on', element);
    }
  }
  element.addEventListener(eventName, handler);

  // Return handler to allow to disable the prevention. Usage:
  // const preventionHandler = preventEvent(el, 'click');
  // el.removeEventHandler('click', preventionHandler);
  return handler;
}

function proxyProperty(object, propertyName, sourceObject, copyFirst) {
  function get() {
    return sourceObject[propertyName];
  }
  function set(value) {
    sourceObject[propertyName] = value;
  }

  if (copyFirst) {
    set(object[propertyName]);
  }

  Object.defineProperty(object, propertyName, {get: get, set: set});
}

function proxyEvent(object, eventName, sourceObject) {
  sourceObject.addEventListener(eventName, function () { return object.dispatchEvent(new Event(eventName)); });
}

function dispatchEventAsync(element, type) {
  Promise.resolve().then(function () {
    element.dispatchEvent(new Event(type));
  });
}

var iOS8or9 = typeof document === 'object' && 'object-fit' in document.head.style && !matchMedia('(-webkit-video-playable-inline)').matches;

var IIV = 'bfred-it:iphone-inline-video';
var IIVEvent = 'bfred-it:iphone-inline-video:event';
var IIVPlay = 'bfred-it:iphone-inline-video:nativeplay';
var IIVPause = 'bfred-it:iphone-inline-video:nativepause';

/**
 * UTILS
 */

function getAudioFromVideo(video) {
  var audio = new Audio();
  proxyEvent(video, 'play', audio);
  proxyEvent(video, 'playing', audio);
  proxyEvent(video, 'pause', audio);
  audio.crossOrigin = video.crossOrigin;

  // 'data:' causes audio.networkState > 0
  // which then allows to keep <audio> in a resumable playing state
  // i.e. once you set a real src it will keep playing if it was if .play() was called
  audio.src = video.src || video.currentSrc || 'data:';

  // // if (audio.src === 'data:') {
  //   TODO: wait for video to be selected
  // // }
  return audio;
}

var lastRequests = [];
var requestIndex = 0;
var lastTimeupdateEvent;

function setTime(video, time, rememberOnly) {
  // Allow one timeupdate event every 200+ ms
  if ((lastTimeupdateEvent || 0) + 200 < Date.now()) {
    video[IIVEvent] = true;
    lastTimeupdateEvent = Date.now();
  }
  if (!rememberOnly) {
    video.currentTime = time;
  }
  lastRequests[++requestIndex % 3] = time * 100 | 0 / 100;
}

function isPlayerEnded(player) {
  return player.driver.currentTime >= player.video.duration;
}

function update(timeDiff) {
  var player = this;
  // // console.log('update', player.video.readyState, player.video.networkState, player.driver.readyState, player.driver.networkState, player.driver.paused);
  if (player.video.readyState >= player.video.HAVE_FUTURE_DATA) {
    if (!player.hasAudio) {
      player.driver.currentTime = player.video.currentTime + ((timeDiff * player.video.playbackRate) / 1000);
      if (player.video.loop && isPlayerEnded(player)) {
        player.driver.currentTime = 0;
      }
    }
    setTime(player.video, player.driver.currentTime);
  } else if (player.video.networkState === player.video.NETWORK_IDLE && player.video.buffered.length === 0) {
    // This should happen when the source is available but:
    // - it's potentially playing (.paused === false)
    // - it's not ready to play
    // - it's not loading
    // If it hasAudio, that will be loaded in the 'emptied' handler below
    player.video.load();
    // // console.log('Will load');
  }

  // // console.assert(player.video.currentTime === player.driver.currentTime, 'Video not updating!');

  if (player.video.ended) {
    delete player.video[IIVEvent]; // Allow timeupdate event
    player.video.pause(true);
  }
}

/**
 * METHODS
 */

function play() {
  // // console.log('play');
  var video = this;
  var player = video[IIV];

  // If it's fullscreen, use the native player
  if (video.webkitDisplayingFullscreen) {
    video[IIVPlay]();
    return;
  }

  if (player.driver.src !== 'data:' && player.driver.src !== video.src) {
    // // console.log('src changed on play', video.src);
    setTime(video, 0, true);
    player.driver.src = video.src;
  }

  if (!video.paused) {
    return;
  }
  player.paused = false;

  if (video.buffered.length === 0) {
    // .load() causes the emptied event
    // the alternative is .play()+.pause() but that triggers play/pause events, even worse
    // possibly the alternative is preventing this event only once
    video.load();
  }

  player.driver.play();
  player.updater.start();

  if (!player.hasAudio) {
    dispatchEventAsync(video, 'play');
    if (player.video.readyState >= player.video.HAVE_ENOUGH_DATA) {
      // // console.log('onplay');
      dispatchEventAsync(video, 'playing');
    }
  }
}
function pause(forceEvents) {
  // // console.log('pause');
  var video = this;
  var player = video[IIV];

  player.driver.pause();
  player.updater.stop();

  // If it's fullscreen, the developer the native player.pause()
  // This is at the end of pause() because it also
  // needs to make sure that the simulation is paused
  if (video.webkitDisplayingFullscreen) {
    video[IIVPause]();
  }

  if (player.paused && !forceEvents) {
    return;
  }

  player.paused = true;
  if (!player.hasAudio) {
    dispatchEventAsync(video, 'pause');
  }

  // Handle the 'ended' event only if it's not fullscreen
  if (video.ended && !video.webkitDisplayingFullscreen) {
    video[IIVEvent] = true;
    dispatchEventAsync(video, 'ended');
  }
}

/**
 * SETUP
 */

function addPlayer(video, hasAudio) {
  var player = {};
  video[IIV] = player;
  player.paused = true; // Track whether 'pause' events have been fired
  player.hasAudio = hasAudio;
  player.video = video;
  player.updater = frameIntervalometer(update.bind(player));

  if (hasAudio) {
    player.driver = getAudioFromVideo(video);
  } else {
    video.addEventListener('canplay', function () {
      if (!video.paused) {
        // // console.log('oncanplay');
        dispatchEventAsync(video, 'playing');
      }
    });
    player.driver = {
      src: video.src || video.currentSrc || 'data:',
      muted: true,
      paused: true,
      pause: function () {
        player.driver.paused = true;
      },
      play: function () {
        player.driver.paused = false;
        // Media automatically goes to 0 if .play() is called when it's done
        if (isPlayerEnded(player)) {
          setTime(video, 0);
        }
      },
      get ended() {
        return isPlayerEnded(player);
      }
    };
  }

  // .load() causes the emptied event
  video.addEventListener('emptied', function () {
    // // console.log('driver src is', player.driver.src);
    var wasEmpty = !player.driver.src || player.driver.src === 'data:';
    if (player.driver.src && player.driver.src !== video.src) {
      // // console.log('src changed to', video.src);
      setTime(video, 0, true);
      player.driver.src = video.src;
      // Playing videos will only keep playing if no src was present when .play()’ed
      if (wasEmpty || (!hasAudio && video.autoplay)) {
        player.driver.play();
      } else {
        player.updater.stop();
      }
    }
  }, false);

  // Stop programmatic player when OS takes over
  video.addEventListener('webkitbeginfullscreen', function () {
    if (!video.paused) {
      // Make sure that the <audio> and the syncer/updater are stopped
      video.pause();

      // Play video natively
      video[IIVPlay]();
    } else if (hasAudio && player.driver.buffered.length === 0) {
      // If the first play is native,
      // the <audio> needs to be buffered manually
      // so when the fullscreen ends, it can be set to the same current time
      player.driver.load();
    }
  });
  if (hasAudio) {
    video.addEventListener('webkitendfullscreen', function () {
      // Sync audio to new video position
      player.driver.currentTime = video.currentTime;
      // // console.assert(player.driver.currentTime === video.currentTime, 'Audio not synced');
    });

    // Allow seeking
    video.addEventListener('seeking', function () {
      if (lastRequests.indexOf(video.currentTime * 100 | 0 / 100) < 0) {
        // // console.log('User-requested seeking');
        player.driver.currentTime = video.currentTime;
      }
    });
  }
}

function preventWithPropOrFullscreen(el) {
  var isAllowed = el[IIVEvent];
  delete el[IIVEvent];
  return !el.webkitDisplayingFullscreen && !isAllowed;
}

function overloadAPI(video) {
  var player = video[IIV];
  video[IIVPlay] = video.play;
  video[IIVPause] = video.pause;
  video.play = play;
  video.pause = pause;
  proxyProperty(video, 'paused', player.driver);
  proxyProperty(video, 'muted', player.driver, true);
  proxyProperty(video, 'playbackRate', player.driver, true);
  proxyProperty(video, 'ended', player.driver);
  proxyProperty(video, 'loop', player.driver, true);

  // IIV works by seeking 60 times per second.
  // These events are now useless.
  preventEvent(video, 'seeking', function (el) { return !el.webkitDisplayingFullscreen; });
  preventEvent(video, 'seeked', function (el) { return !el.webkitDisplayingFullscreen; });

  // Limit timeupdate events
  preventEvent(video, 'timeupdate', preventWithPropOrFullscreen);

  // Prevent occasional native ended events
  preventEvent(video, 'ended', preventWithPropOrFullscreen);
}

function enableInlineVideo(video, opts) {
  if ( opts === void 0 ) opts = {};

  // Stop if already enabled
  if (video[IIV]) {
    return;
  }

  // Allow the user to skip detection
  if (!opts.everywhere) {
    // Only iOS8 and 9 are supported
    if (!iOS8or9) {
      return;
    }

    // Stop if it's not an allowed device
    if (!(opts.iPad || opts.ipad ? /iPhone|iPod|iPad/ : /iPhone|iPod/).test(navigator.userAgent)) {
      return;
    }
  }

  // Try to pause
  video.pause();

  // Prevent autoplay.
  // An non-started autoplaying video can't be .pause()'d
  var willAutoplay = video.autoplay;
  video.autoplay = false;

  addPlayer(video, !video.muted);
  overloadAPI(video);
  video.classList.add('IIV');

  // Autoplay
  if (video.muted && willAutoplay) {
    video.play();
    video.addEventListener('playing', function restoreAutoplay() {
      video.autoplay = true;
      video.removeEventListener('playing', restoreAutoplay);
    });
  }

  if (!/iPhone|iPod|iPad/.test(navigator.platform)) {
    console.warn('iphone-inline-video is not guaranteed to work in emulated environments');
  }
}

return enableInlineVideo;

}());
</script>


<script type="text/javascript">
  var videos = document.querySelectorAll('video');
var behavior = document.querySelector('#behavior');

if (location.search === '?enabled=false') {
  behavior.innerHTML = '(module disabled everywhere via <code>?enabled=false</code>';
} else if (location.search === '?enabled=true') {
  enableVideos(true);
  behavior.innerHTML = '(module enabled everywhere (whether it’s necessary or not) via <code>?enabled=true</code>)';
} else {
  enableVideos();
}

function enableButtons(video) {
  var playBtn = video.parentNode.querySelector('.play');
  var fullscreenButton = video.parentNode.querySelector('.fullscreen');

  if (playBtn) {
    playBtn.addEventListener('click', function () {
      if (video.paused) {
        video.play();
      } else {
        video.pause();
      }
    });
  }

  if (fullscreenButton) {
    fullscreenButton.addEventListener('click', function () {
      video.webkitEnterFullScreen();
    });
  }
}

// debug events
function debugEvents(video) {
  [
    'loadstart',
    'progress',
    'suspend',
    'abort',
    'error',
    'emptied',
    'stalled',
    'loadedmetadata',
    'loadeddata',
    'canplay',
    'canplaythrough',
    'playing', // fake event
    'waiting',
    'seeking',
    'seeked',
    'ended',
  // 'durationchange',
    'timeupdate',
    'play', // fake event
    'pause', // fake event
  // 'ratechange',
  // 'resize',
  // 'volumechange',
    'webkitbeginfullscreen',
    'webkitendfullscreen',
  ].forEach(function (event) {
    video.addEventListener(event, function () {
      console.info('@', event);
    });
  });
}

function enableVideos(everywhere) {
  for (var i = 0; i < videos.length; i++) {
    window.enableInlineVideo(videos[i], {everywhere: everywhere});
    enableButtons(videos[i]);
    debugEvents(videos[i]);
  }
}
</script>